#![doc = "Peripheral access API for CH573SFR microcontrollers (generated using svd2rust v0.37.1 ( ))\n\nYou can find an overview of the generated API [here].\n\nAPI features to be included in the [next] svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.\n\n[here]: https://docs.rs/svd2rust/0.37.1/svd2rust/#peripheral-api\n[next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased\n[repository]: https://github.com/rust-embedded/svd2rust"]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![no_std]
#![cfg_attr(docsrs, feature(doc_cfg))]
#[doc = r"Number available in the NVIC for configuring priority"]
pub const NVIC_PRIO_BITS: u8 = 2;
#[allow(unused_imports)]
use generic::*;
#[doc = r"Common register and bit access and modify traits"]
pub mod generic;
#[cfg(feature = "rt")]
extern "C" {
    fn TMR0();
    fn GPIO_A();
    fn GPIO_B();
    fn SPI0();
    fn BLEL();
    fn BLEB();
    fn USB();
    fn TMR2();
    fn UART0();
    fn UART1();
    fn RTC();
    fn ADC();
    fn TMR3();
    fn UART2();
    fn UART3();
    fn WDOG_BAT();
}
#[doc(hidden)]
#[repr(C)]
pub union Vector {
    _handler: unsafe extern "C" fn(),
    _reserved: u32,
}
#[cfg(feature = "rt")]
#[doc(hidden)]
#[link_section = ".vector_table.interrupts"]
#[no_mangle]
pub static __INTERRUPTS: [Vector; 22] = [
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: TMR0 },
    Vector { _handler: GPIO_A },
    Vector { _handler: GPIO_B },
    Vector { _handler: SPI0 },
    Vector { _handler: BLEL },
    Vector { _handler: BLEB },
    Vector { _handler: USB },
    Vector { _handler: TMR2 },
    Vector { _handler: UART0 },
    Vector { _handler: UART1 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: RTC },
    Vector { _handler: ADC },
    Vector { _handler: TMR3 },
    Vector { _handler: UART2 },
    Vector { _handler: UART3 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: WDOG_BAT },
];
#[doc = r"Enumeration of all the interrupts."]
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
#[repr(u16)]
pub enum Interrupt {
    #[doc = "2 - TMR0_IRQHandler"]
    TMR0 = 2,
    #[doc = "3 - GPIO_IRQHandler"]
    GPIO_A = 3,
    #[doc = "4 - GPIO_IRQHandler"]
    GPIO_B = 4,
    #[doc = "5 - SPI0_IRQHandler"]
    SPI0 = 5,
    #[doc = "6 - LLE_IRQHandler"]
    BLEL = 6,
    #[doc = "7 - BB_IRQHandler"]
    BLEB = 7,
    #[doc = "8 - USB_IRQHandler"]
    USB = 8,
    #[doc = "9 - TMR2_IRQHandler"]
    TMR2 = 9,
    #[doc = "10 - UART0_IRQHandler"]
    UART0 = 10,
    #[doc = "11 - UART1_IRQHandler"]
    UART1 = 11,
    #[doc = "14 - RTC_IRQHandler"]
    RTC = 14,
    #[doc = "15 - ADC_IRQHandler"]
    ADC = 15,
    #[doc = "16 - TMR3_IRQHandler"]
    TMR3 = 16,
    #[doc = "17 - UART1_IRQHandler"]
    UART2 = 17,
    #[doc = "18 - UART3_IRQHandler"]
    UART3 = 18,
    #[doc = "21 - WDT_IRQHandler"]
    WDOG_BAT = 21,
}
#[doc = "System Control Register"]
pub type Sys = crate::Periph<sys::RegisterBlock, 0x4000_1000>;
impl core::fmt::Debug for Sys {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Sys").finish()
    }
}
#[doc = "System Control Register"]
pub mod sys;
#[doc = "Timer0 register"]
pub type Tmr0 = crate::Periph<tmr0::RegisterBlock, 0x4000_2000>;
impl core::fmt::Debug for Tmr0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Tmr0").finish()
    }
}
#[doc = "Timer0 register"]
pub mod tmr0;
#[doc = "Timer1 register"]
pub type Tmr1 = crate::Periph<tmr1::RegisterBlock, 0x4000_2400>;
impl core::fmt::Debug for Tmr1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Tmr1").finish()
    }
}
#[doc = "Timer1 register"]
pub mod tmr1;
#[doc = "Timer2 register"]
pub type Tmr2 = crate::Periph<tmr2::RegisterBlock, 0x4000_2800>;
impl core::fmt::Debug for Tmr2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Tmr2").finish()
    }
}
#[doc = "Timer2 register"]
pub mod tmr2;
#[doc = "Timer3 register"]
pub type Tmr3 = crate::Periph<tmr3::RegisterBlock, 0x4000_2c00>;
impl core::fmt::Debug for Tmr3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Tmr3").finish()
    }
}
#[doc = "Timer3 register"]
pub mod tmr3;
#[doc = "UART0 register"]
pub type Uart0 = crate::Periph<uart0::RegisterBlock, 0x4000_3000>;
impl core::fmt::Debug for Uart0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Uart0").finish()
    }
}
#[doc = "UART0 register"]
pub mod uart0;
#[doc = "UART1 register"]
pub type Uart1 = crate::Periph<uart1::RegisterBlock, 0x4000_3400>;
impl core::fmt::Debug for Uart1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Uart1").finish()
    }
}
#[doc = "UART1 register"]
pub mod uart1;
#[doc = "UART2 register"]
pub type Uart2 = crate::Periph<uart2::RegisterBlock, 0x4000_3800>;
impl core::fmt::Debug for Uart2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Uart2").finish()
    }
}
#[doc = "UART2 register"]
pub mod uart2;
#[doc = "UART3 register"]
pub type Uart3 = crate::Periph<uart3::RegisterBlock, 0x4000_3c00>;
impl core::fmt::Debug for Uart3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Uart3").finish()
    }
}
#[doc = "UART3 register"]
pub mod uart3;
#[doc = "SPI0 register"]
pub type Spi0 = crate::Periph<spi0::RegisterBlock, 0x4000_4000>;
impl core::fmt::Debug for Spi0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Spi0").finish()
    }
}
#[doc = "SPI0 register"]
pub mod spi0;
#[doc = "PWMx register"]
pub type Pwmx = crate::Periph<pwmx::RegisterBlock, 0x4000_5000>;
impl core::fmt::Debug for Pwmx {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pwmx").finish()
    }
}
#[doc = "PWMx register"]
pub mod pwmx;
#[doc = "USB register"]
pub type Usb = crate::Periph<usb::RegisterBlock, 0x4000_8000>;
impl core::fmt::Debug for Usb {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Usb").finish()
    }
}
#[doc = "USB register"]
pub mod usb;
#[doc = "Program Fast Interrupt Controller"]
pub type Pfic = crate::Periph<pfic::RegisterBlock, 0xe000_e000>;
impl core::fmt::Debug for Pfic {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pfic").finish()
    }
}
#[doc = "Program Fast Interrupt Controller"]
pub mod pfic;
#[doc = "Systick register"]
pub type Systick = crate::Periph<systick::RegisterBlock, 0xe000_f000>;
impl core::fmt::Debug for Systick {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Systick").finish()
    }
}
#[doc = "Systick register"]
pub mod systick;
#[no_mangle]
static mut DEVICE_PERIPHERALS: bool = false;
#[doc = r" All the peripherals."]
#[allow(non_snake_case)]
pub struct Peripherals {
    #[doc = "SYS"]
    pub sys: Sys,
    #[doc = "TMR0"]
    pub tmr0: Tmr0,
    #[doc = "TMR1"]
    pub tmr1: Tmr1,
    #[doc = "TMR2"]
    pub tmr2: Tmr2,
    #[doc = "TMR3"]
    pub tmr3: Tmr3,
    #[doc = "UART0"]
    pub uart0: Uart0,
    #[doc = "UART1"]
    pub uart1: Uart1,
    #[doc = "UART2"]
    pub uart2: Uart2,
    #[doc = "UART3"]
    pub uart3: Uart3,
    #[doc = "SPI0"]
    pub spi0: Spi0,
    #[doc = "PWMx"]
    pub pwmx: Pwmx,
    #[doc = "USB"]
    pub usb: Usb,
    #[doc = "PFIC"]
    pub pfic: Pfic,
    #[doc = "Systick"]
    pub systick: Systick,
}
impl Peripherals {
    #[doc = r" Returns all the peripherals *once*."]
    #[cfg(feature = "critical-section")]
    #[inline]
    pub fn take() -> Option<Self> {
        critical_section::with(|_| {
            if unsafe { DEVICE_PERIPHERALS } {
                return None;
            }
            Some(unsafe { Peripherals::steal() })
        })
    }
    #[doc = r" Unchecked version of `Peripherals::take`."]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Each of the returned peripherals must be used at most once."]
    #[inline]
    pub unsafe fn steal() -> Self {
        DEVICE_PERIPHERALS = true;
        Peripherals {
            sys: Sys::steal(),
            tmr0: Tmr0::steal(),
            tmr1: Tmr1::steal(),
            tmr2: Tmr2::steal(),
            tmr3: Tmr3::steal(),
            uart0: Uart0::steal(),
            uart1: Uart1::steal(),
            uart2: Uart2::steal(),
            uart3: Uart3::steal(),
            spi0: Spi0::steal(),
            pwmx: Pwmx::steal(),
            usb: Usb::steal(),
            pfic: Pfic::steal(),
            systick: Systick::steal(),
        }
    }
}
